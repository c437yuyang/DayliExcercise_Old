/*
一个只包含'A'、'B'和'C'的字符串，如果存在某一段长度为3的连续子串中恰好'A'、'B'和'C'各有一个，那么这个字符串就是纯净的，否则这个字符串就是暗黑的。例如：
BAACAACCBAAA 连续子串"CBA"中包含了'A','B','C'各一个，所以是纯净的字符串
AABBCCAABB 不存在一个长度为3的连续子串包含'A','B','C',所以是暗黑的字符串
你的任务就是计算出长度为n的字符串(只包含'A'、'B'和'C')，有多少个是暗黑的字符串。
输入描述:
输入一个整数n，表示字符串长度(1 ≤ n ≤ 30)
输出描述:
输出一个整数表示有多少个暗黑字符串
示例1
输入
复制
2 3
输出
复制
9 21
*/

#include<iostream>
#include<string>
using namespace std;
//先强行dfs找了一波答案
 //发现数列是 3 9 21 51 123...
 //好，发现规律了，a[n]=2*a[n-1]+a[n-2],那就可以秒掉了~
int main()
{
    int n;
    while(cin>>n)
      {
          long long f[31];  //注意结果有可能超出int型范围，需要用long long型
          f[1]=3;
          f[2]=9;
          for(int i=3;i<=n;i++)
              f[i]=2*f[i-1]+f[i-2];  //递推公式需证明
          cout<<f[n]<<endl;
      }
    return 0;
}