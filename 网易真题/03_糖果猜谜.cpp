///*
//小明是幼儿园的一名老师。某天幼儿园园长给小朋友们每人发一颗糖果，小朋友们拿到后发现有一些同学拿到的糖果颜色和自己相同，有一些同学糖果颜色和自己不同。
//假定每个小朋友只知道有多少同学和自己拿到了相同颜色的糖果。
//上课后，有一部分小朋友兴奋的把这一结果告诉小明老师，并让小明老师猜一猜，最少有多少同学拿到了糖果。
//例如有三个小朋友告诉小明老师这一结果如下：
//其中第一个小朋友发现有1人和自己糖果颜色一样，第二个小朋友也发现有1人和自己糖果颜色一样，第三个小朋友发现有3人和自己糖果颜色一样。
//第一二个小朋友可互相认为对方和自己颜色相同，比如红色；
//第三个小朋友不可能再为红色（否则第一二个小朋友会发现有2人和自己糖果颜色相同），假设他拿到的为蓝色糖果，那么至少还有另外3位同学拿到蓝色的糖果，最终至少有6位小朋友拿到了糖果。
//现在请你帮助小明老师解答下这个谜题。
//
//输入描述:
//假定部分小朋友的回答用空格间隔，如 1 1 3
//
//
//输出描述:
//直接打印最少有多少位小朋友拿到糖果
//如 6
//
//输入例子1:
//1 1 3
//
//输出例子1:
//6
//
//输入例子2:
//0 0 0
//
//输出例子2:
//3
//
//例子说明2:
//三位小朋友都没发现有人和自己的颜色相同，所以最少的情况就是三位小朋友糖果的颜色均不同
//
//*/


//我想多了，其实很简单
//假如 1,1,1,2,2  结算两个1，剩下1,2,2,这个1  一定的加两个人，不能从2里面找一个人，因为2这个人，一定还有跟他一样的，因此和1这个人的假设不成立!!!

//牛客看到的
#include<iostream>
#include<unordered_map>
#include<vector>

using namespace std;

int main()

{
	int temp;
	unordered_map<int, int> m;
	while (cin >> temp)
	{
		m[temp]++;
	} //统计每种有1,2,3...个相同的有几个人
	int res = 0;
	for (auto iter = m.begin(); iter != m.end(); iter++)
	{
		int val = iter->first;
		int cnt = iter->second;
		res += cnt / (val + 1)*(val + 1); //1个相同的需要结算两个人，所以除以val+1

		if (cnt % (val + 1) == 0)
			continue;
		else
			res += (val + 1); //多余的也必须按照最大的这个结算，比如剩下一个1，就必须2个人，剩下一个3，就必须4个人
	}

	cout << res << endl;
	return 0;
}